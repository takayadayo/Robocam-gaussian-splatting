"""
undistort_for_colmap.py

Usage:
    python known_pose_sfm_BA.py --images_txt output\images.txt --intrinsics_yaml sfm_out\intrinsics.yaml --image_dir undistortion\images --output_ply known_pose_BA/output_points_BA.ply

Description:
    - Loads K, dist from YAML.
    - Undistorts all images in image_dir.
    - Computes optimal new camera matrix (Pinhole).
    - Writes COLMAP formatted cameras.txt (PINHOLE) and images.txt.
"""

import argparse
import os
import glob
import shutil
import cv2
import numpy as np

from typing import Dict

def load_intrinsics(yaml_path):
    fs = cv2.FileStorage(yaml_path, cv2.FILE_STORAGE_READ)
    if not fs.isOpened():
        raise FileNotFoundError(f"Cannot open {yaml_path}")
    K = fs.getNode("K").mat()
    dist = fs.getNode("dist").mat().ravel()
    fs.release()
    return K, dist

def qvec2rotmat(qvec):
    return np.array([
        [1 - 2 * qvec[2]**2 - 2 * qvec[3]**2,
         2 * qvec[1] * qvec[2] - 2 * qvec[0] * qvec[3],
         2 * qvec[1] * qvec[3] + 2 * qvec[0] * qvec[2]],
        [2 * qvec[1] * qvec[2] + 2 * qvec[0] * qvec[3],
         1 - 2 * qvec[1]**2 - 2 * qvec[3]**2,
         2 * qvec[2] * qvec[3] - 2 * qvec[0] * qvec[1]],
        [2 * qvec[1] * qvec[3] - 2 * qvec[0] * qvec[2],
         2 * qvec[2] * qvec[3] + 2 * qvec[0] * qvec[1],
         1 - 2 * qvec[1]**2 - 2 * qvec[2]**2]
    ])

def rotmat2qvec(R):
    Rxx, Ryx, Rzx, Rxy, Ryy, Rzy, Rxz, Ryz, Rzz = R.flat
    K = np.array([
        [Rxx - Ryy - Rzz, 0, 0, 0],
        [Ryx + Rxy, Ryy - Rxx - Rzz, 0, 0],
        [Rzx + Rxz, Rzy + Ryz, Rzz - Rxx - Ryy, 0],
        [Ryz - Rzy, Rzx - Rxz, Rxy - Ryx, Rxx + Ryy + Rzz]]) / 3.0
    vals, vecs = np.linalg.eigh(K)
    q = vecs[[3, 0, 1, 2], np.argmax(vals)]
    if q[0] < 0:
        q *= -1
    return q

def save_yaml(path: str, data: Dict[str, np.ndarray]):
    fs = cv2.FileStorage(path, cv2.FILE_STORAGE_WRITE)
    if not fs.isOpened():
        raise RuntimeError(f"Could not open {path} for writing.")
    for k, v in data.items():
        fs.write(k, np.array(v))
    fs.release()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--image_dir", required=True, help="Path to original (distorted) images")
    parser.add_argument("--intrinsics_yaml", required=True, help="Path to intrinsics.yaml with K and dist")
    # parser.add_argument("--input_colmap_images_txt", required=True, help="Path to images.txt generated by handeye pipeline")
    parser.add_argument("--output_dir", required=True, help="Output directory for 3DGS (images/ and sparse/0/)")
    parser.add_argument("--alpha", type=float, default=0.0, help="Alpha for getOptimalNewCameraMatrix (0=crop, 1=full)")
    args = parser.parse_args()

    # Setup directories
    out_img_dir = os.path.join(args.output_dir, "images")
    out_sparse_dir = os.path.join(args.output_dir, "sparse", "0")
    os.makedirs(out_img_dir, exist_ok=True)
    os.makedirs(out_sparse_dir, exist_ok=True)

    # 1. Load Intrinsics
    print(f"Loading intrinsics from {args.intrinsics_yaml}")
    K, dist = load_intrinsics(args.intrinsics_yaml)
    print("Original K:\n", K)
    print("Distortion:", dist)

    # 2. Process Images and Compute New K
    image_paths = sorted(glob.glob(os.path.join(args.image_dir, "*")))
    if not image_paths:
        raise RuntimeError("No images found.")

    # Get size from first image
    first_img = cv2.imread(image_paths[0])
    if first_img is None:
        raise RuntimeError(f"Failed to read {image_paths[0]}")
    h, w = first_img.shape[:2]

    # Compute Optimal New Camera Matrix
    # alpha=0: 画像の有効範囲内のみを切り出す（黒枠なし、ズームされる）
    # alpha=1: 全画素を残す（黒枠が出る可能性あり）。3DGSには黒枠は悪影響なので alpha=0 推奨。
    new_K, roi = cv2.getOptimalNewCameraMatrix(K, dist, (w, h), args.alpha, (w, h))

    # ROI crop をするか（alpha=0 のときは基本 crop 推奨）
    x, y, rw, rh = roi
    do_crop = (args.alpha == 0.0) and (rw > 0) and (rh > 0)

    # map は (w,h) で作って、最後に crop する
    mapx, mapy = cv2.initUndistortRectifyMap(K, dist, None, new_K, (w, h), cv2.CV_32FC1)

    # crop するなら、K の主点を ROI 原点ぶんだけ補正し、出力サイズも更新
    K_out = new_K.copy()
    out_w, out_h = w, h
    if do_crop:
        K_out[0, 2] -= float(x)
        K_out[1, 2] -= float(y)
        out_w, out_h = int(rw), int(rh)

    print("New K (Pinhole):\n", K_out)
    print(f"ROI: {roi}, do_crop={do_crop}, out_size=({out_w},{out_h})")

    for path in image_paths:
        img = cv2.imread(path)
        if img is None:
            continue

        undistorted = cv2.remap(img, mapx, mapy, cv2.INTER_LINEAR)

        if do_crop:
            undistorted = undistorted[y:y+rh, x:x+rw]

        name = os.path.basename(path)
        out_path = os.path.join(out_img_dir, name)
        cv2.imwrite(out_path, undistorted)

    # cameras.txt (PINHOLE): サイズは out_w/out_h、パラメータは K_out
    fx, fy = float(K_out[0, 0]), float(K_out[1, 1])
    cx, cy = float(K_out[0, 2]), float(K_out[1, 2])

    cameras_txt_path = os.path.join(out_sparse_dir, "cameras.txt")
    with open(cameras_txt_path, "w") as f:
        f.write("# Camera list with one line of data per camera.\n")
        f.write("# CAMERA_ID, MODEL, WIDTH, HEIGHT, PARAMS[]\n")
        f.write(f"1 PINHOLE {out_w} {out_h} {fx:.16f} {fy:.16f} {cx:.16f} {cy:.16f}\n")
    print(f"Wrote {cameras_txt_path}")

    # intrinsics.yaml は「入力を上書き」せず、出力側へ保存（事故防止）
    intrinsics_out_path = os.path.join(args.output_dir, "intrinsics.yaml")
    dist0 = np.zeros((5, 1), dtype=np.float64)
    save_yaml(intrinsics_out_path, {"K": K_out, "dist": dist0})
    print(f"[INFO] wrote intrinsics to {intrinsics_out_path}")


    # 4. Process images.txt
    # Poses (R, t) do NOT change because the camera center and orientation 
    # relative to the world are invariant to lens distortion correction.
    # Only the projection (K) changes.
    
    # images_txt_path = os.path.join(out_sparse_dir, "images.txt")
    
    # if os.path.exists(args.input_colmap_images_txt):
    #     print(f"Transferring poses from {args.input_colmap_images_txt}...")
        
    #     with open(args.input_colmap_images_txt, "r") as fin, \
    #          open(images_txt_path, "w") as fout:
            
    #         fout.write("# Image list with two lines of data per image.\n")
    #         fout.write("# IMAGE_ID, QW, QX, QY, QZ, TX, TY, TZ, CAMERA_ID, NAME\n")
    #         fout.write("# POINTS2D[] as (X, Y, POINT3D_ID)\n")
            
    #         lines = fin.readlines()
    #         for line in lines:
    #             line = line.strip()
    #             if not line or line.startswith("#"):
    #                 continue
                
    #             parts = line.split()
    #             # Image definition line has at least 9-10 parts
    #             # 3D points line has other structure
                
    #             # Check if it is an image line (contains filename at end)
    #             # COLMAP format: ID, QW, QX, QY, QZ, TX, TY, TZ, CAM_ID, NAME
    #             if len(parts) >= 9:
    #                 # Keep ID, Q, T
    #                 # Force Camera ID to 1 (since we wrote camera 1 in cameras.txt)
    #                 parts[8] = "1" 
    #                 fout.write(" ".join(parts) + "\n")
                    
    #                 # Write empty line for points (since we don't have 2D features tracked on undistorted images yet)
    #                 fout.write("\n")
                    
    #     print(f"Wrote {images_txt_path}")
    # else:
    #     print("Warning: Input images.txt not found. You will need to provide poses manually.")

    # 5. Handle points3D.txt (Optional)
    # If the user has a points3D.txt from the previous pipeline, 
    # the 3D coordinates (XYZ) are valid, but the 2D tracks are invalid for the new images.
    # For 3DGS initialization, only XYZ and RGB are usually needed.
    # However, it is safer to regenerate points using known_pose_sfm_baseline.py 
    # WITH the new undistorted images and new K.
    print("\n[Recommendation]")
    print("1. Use the 'images' folder and 'sparse/0' folder generated here for 3DGS.")
    print("2. If you need an initial point cloud:")
    print("   Run 'known_pose_sfm_baseline.py' AGAIN using:")
    print(f"     --image_dir {out_img_dir}")
    # print(f"     --images_txt {images_txt_path}")
    print("     --intrinsics_yaml (Create a new simple yaml with new K and dist=0)")
    
if __name__ == "__main__":
    main()